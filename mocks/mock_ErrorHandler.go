// Code generated by mockery v2.46.0. DO NOT EDIT.

package arpcmocks

import (
	arpc "github.com/a-novel-kit/arpc"
	codes "google.golang.org/grpc/codes"

	mock "github.com/stretchr/testify/mock"
)

// MockErrorHandler is an autogenerated mock type for the ErrorHandler type
type MockErrorHandler struct {
	mock.Mock
}

type MockErrorHandler_Expecter struct {
	mock *mock.Mock
}

func (_m *MockErrorHandler) EXPECT() *MockErrorHandler_Expecter {
	return &MockErrorHandler_Expecter{mock: &_m.Mock}
}

// As provides a mock function with given fields: target, code
func (_m *MockErrorHandler) As(target interface{}, code codes.Code) arpc.ErrorHandler {
	ret := _m.Called(target, code)

	if len(ret) == 0 {
		panic("no return value specified for As")
	}

	var r0 arpc.ErrorHandler
	if rf, ok := ret.Get(0).(func(interface{}, codes.Code) arpc.ErrorHandler); ok {
		r0 = rf(target, code)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(arpc.ErrorHandler)
		}
	}

	return r0
}

// MockErrorHandler_As_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'As'
type MockErrorHandler_As_Call struct {
	*mock.Call
}

// As is a helper method to define mock.On call
//   - target interface{}
//   - code codes.Code
func (_e *MockErrorHandler_Expecter) As(target interface{}, code interface{}) *MockErrorHandler_As_Call {
	return &MockErrorHandler_As_Call{Call: _e.mock.On("As", target, code)}
}

func (_c *MockErrorHandler_As_Call) Run(run func(target interface{}, code codes.Code)) *MockErrorHandler_As_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(interface{}), args[1].(codes.Code))
	})
	return _c
}

func (_c *MockErrorHandler_As_Call) Return(_a0 arpc.ErrorHandler) *MockErrorHandler_As_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockErrorHandler_As_Call) RunAndReturn(run func(interface{}, codes.Code) arpc.ErrorHandler) *MockErrorHandler_As_Call {
	_c.Call.Return(run)
	return _c
}

// AsW provides a mock function with given fields: target, code, wrap
func (_m *MockErrorHandler) AsW(target interface{}, code codes.Code, wrap error) arpc.ErrorHandler {
	ret := _m.Called(target, code, wrap)

	if len(ret) == 0 {
		panic("no return value specified for AsW")
	}

	var r0 arpc.ErrorHandler
	if rf, ok := ret.Get(0).(func(interface{}, codes.Code, error) arpc.ErrorHandler); ok {
		r0 = rf(target, code, wrap)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(arpc.ErrorHandler)
		}
	}

	return r0
}

// MockErrorHandler_AsW_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AsW'
type MockErrorHandler_AsW_Call struct {
	*mock.Call
}

// AsW is a helper method to define mock.On call
//   - target interface{}
//   - code codes.Code
//   - wrap error
func (_e *MockErrorHandler_Expecter) AsW(target interface{}, code interface{}, wrap interface{}) *MockErrorHandler_AsW_Call {
	return &MockErrorHandler_AsW_Call{Call: _e.mock.On("AsW", target, code, wrap)}
}

func (_c *MockErrorHandler_AsW_Call) Run(run func(target interface{}, code codes.Code, wrap error)) *MockErrorHandler_AsW_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(interface{}), args[1].(codes.Code), args[2].(error))
	})
	return _c
}

func (_c *MockErrorHandler_AsW_Call) Return(_a0 arpc.ErrorHandler) *MockErrorHandler_AsW_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockErrorHandler_AsW_Call) RunAndReturn(run func(interface{}, codes.Code, error) arpc.ErrorHandler) *MockErrorHandler_AsW_Call {
	_c.Call.Return(run)
	return _c
}

// AsWF provides a mock function with given fields: target, code, format, args
func (_m *MockErrorHandler) AsWF(target interface{}, code codes.Code, format string, args ...interface{}) arpc.ErrorHandler {
	var _ca []interface{}
	_ca = append(_ca, target, code, format)
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AsWF")
	}

	var r0 arpc.ErrorHandler
	if rf, ok := ret.Get(0).(func(interface{}, codes.Code, string, ...interface{}) arpc.ErrorHandler); ok {
		r0 = rf(target, code, format, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(arpc.ErrorHandler)
		}
	}

	return r0
}

// MockErrorHandler_AsWF_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AsWF'
type MockErrorHandler_AsWF_Call struct {
	*mock.Call
}

// AsWF is a helper method to define mock.On call
//   - target interface{}
//   - code codes.Code
//   - format string
//   - args ...interface{}
func (_e *MockErrorHandler_Expecter) AsWF(target interface{}, code interface{}, format interface{}, args ...interface{}) *MockErrorHandler_AsWF_Call {
	return &MockErrorHandler_AsWF_Call{Call: _e.mock.On("AsWF",
		append([]interface{}{target, code, format}, args...)...)}
}

func (_c *MockErrorHandler_AsWF_Call) Run(run func(target interface{}, code codes.Code, format string, args ...interface{})) *MockErrorHandler_AsWF_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(interface{}), args[1].(codes.Code), args[2].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockErrorHandler_AsWF_Call) Return(_a0 arpc.ErrorHandler) *MockErrorHandler_AsWF_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockErrorHandler_AsWF_Call) RunAndReturn(run func(interface{}, codes.Code, string, ...interface{}) arpc.ErrorHandler) *MockErrorHandler_AsWF_Call {
	_c.Call.Return(run)
	return _c
}

// Handle provides a mock function with given fields: err
func (_m *MockErrorHandler) Handle(err error) error {
	ret := _m.Called(err)

	if len(ret) == 0 {
		panic("no return value specified for Handle")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(error) error); ok {
		r0 = rf(err)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockErrorHandler_Handle_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Handle'
type MockErrorHandler_Handle_Call struct {
	*mock.Call
}

// Handle is a helper method to define mock.On call
//   - err error
func (_e *MockErrorHandler_Expecter) Handle(err interface{}) *MockErrorHandler_Handle_Call {
	return &MockErrorHandler_Handle_Call{Call: _e.mock.On("Handle", err)}
}

func (_c *MockErrorHandler_Handle_Call) Run(run func(err error)) *MockErrorHandler_Handle_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(error))
	})
	return _c
}

func (_c *MockErrorHandler_Handle_Call) Return(_a0 error) *MockErrorHandler_Handle_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockErrorHandler_Handle_Call) RunAndReturn(run func(error) error) *MockErrorHandler_Handle_Call {
	_c.Call.Return(run)
	return _c
}

// Is provides a mock function with given fields: target, code
func (_m *MockErrorHandler) Is(target error, code codes.Code) arpc.ErrorHandler {
	ret := _m.Called(target, code)

	if len(ret) == 0 {
		panic("no return value specified for Is")
	}

	var r0 arpc.ErrorHandler
	if rf, ok := ret.Get(0).(func(error, codes.Code) arpc.ErrorHandler); ok {
		r0 = rf(target, code)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(arpc.ErrorHandler)
		}
	}

	return r0
}

// MockErrorHandler_Is_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Is'
type MockErrorHandler_Is_Call struct {
	*mock.Call
}

// Is is a helper method to define mock.On call
//   - target error
//   - code codes.Code
func (_e *MockErrorHandler_Expecter) Is(target interface{}, code interface{}) *MockErrorHandler_Is_Call {
	return &MockErrorHandler_Is_Call{Call: _e.mock.On("Is", target, code)}
}

func (_c *MockErrorHandler_Is_Call) Run(run func(target error, code codes.Code)) *MockErrorHandler_Is_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(error), args[1].(codes.Code))
	})
	return _c
}

func (_c *MockErrorHandler_Is_Call) Return(_a0 arpc.ErrorHandler) *MockErrorHandler_Is_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockErrorHandler_Is_Call) RunAndReturn(run func(error, codes.Code) arpc.ErrorHandler) *MockErrorHandler_Is_Call {
	_c.Call.Return(run)
	return _c
}

// IsW provides a mock function with given fields: target, code, wrap
func (_m *MockErrorHandler) IsW(target error, code codes.Code, wrap error) arpc.ErrorHandler {
	ret := _m.Called(target, code, wrap)

	if len(ret) == 0 {
		panic("no return value specified for IsW")
	}

	var r0 arpc.ErrorHandler
	if rf, ok := ret.Get(0).(func(error, codes.Code, error) arpc.ErrorHandler); ok {
		r0 = rf(target, code, wrap)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(arpc.ErrorHandler)
		}
	}

	return r0
}

// MockErrorHandler_IsW_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsW'
type MockErrorHandler_IsW_Call struct {
	*mock.Call
}

// IsW is a helper method to define mock.On call
//   - target error
//   - code codes.Code
//   - wrap error
func (_e *MockErrorHandler_Expecter) IsW(target interface{}, code interface{}, wrap interface{}) *MockErrorHandler_IsW_Call {
	return &MockErrorHandler_IsW_Call{Call: _e.mock.On("IsW", target, code, wrap)}
}

func (_c *MockErrorHandler_IsW_Call) Run(run func(target error, code codes.Code, wrap error)) *MockErrorHandler_IsW_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(error), args[1].(codes.Code), args[2].(error))
	})
	return _c
}

func (_c *MockErrorHandler_IsW_Call) Return(_a0 arpc.ErrorHandler) *MockErrorHandler_IsW_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockErrorHandler_IsW_Call) RunAndReturn(run func(error, codes.Code, error) arpc.ErrorHandler) *MockErrorHandler_IsW_Call {
	_c.Call.Return(run)
	return _c
}

// IsWF provides a mock function with given fields: target, code, format, args
func (_m *MockErrorHandler) IsWF(target error, code codes.Code, format string, args ...interface{}) arpc.ErrorHandler {
	var _ca []interface{}
	_ca = append(_ca, target, code, format)
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for IsWF")
	}

	var r0 arpc.ErrorHandler
	if rf, ok := ret.Get(0).(func(error, codes.Code, string, ...interface{}) arpc.ErrorHandler); ok {
		r0 = rf(target, code, format, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(arpc.ErrorHandler)
		}
	}

	return r0
}

// MockErrorHandler_IsWF_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsWF'
type MockErrorHandler_IsWF_Call struct {
	*mock.Call
}

// IsWF is a helper method to define mock.On call
//   - target error
//   - code codes.Code
//   - format string
//   - args ...interface{}
func (_e *MockErrorHandler_Expecter) IsWF(target interface{}, code interface{}, format interface{}, args ...interface{}) *MockErrorHandler_IsWF_Call {
	return &MockErrorHandler_IsWF_Call{Call: _e.mock.On("IsWF",
		append([]interface{}{target, code, format}, args...)...)}
}

func (_c *MockErrorHandler_IsWF_Call) Run(run func(target error, code codes.Code, format string, args ...interface{})) *MockErrorHandler_IsWF_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(error), args[1].(codes.Code), args[2].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockErrorHandler_IsWF_Call) Return(_a0 arpc.ErrorHandler) *MockErrorHandler_IsWF_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockErrorHandler_IsWF_Call) RunAndReturn(run func(error, codes.Code, string, ...interface{}) arpc.ErrorHandler) *MockErrorHandler_IsWF_Call {
	_c.Call.Return(run)
	return _c
}

// Test provides a mock function with given fields: caseFn
func (_m *MockErrorHandler) Test(caseFn func(error) (error, bool)) arpc.ErrorHandler {
	ret := _m.Called(caseFn)

	if len(ret) == 0 {
		panic("no return value specified for Test")
	}

	var r0 arpc.ErrorHandler
	if rf, ok := ret.Get(0).(func(func(error) (error, bool)) arpc.ErrorHandler); ok {
		r0 = rf(caseFn)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(arpc.ErrorHandler)
		}
	}

	return r0
}

// MockErrorHandler_Test_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Test'
type MockErrorHandler_Test_Call struct {
	*mock.Call
}

// Test is a helper method to define mock.On call
//   - caseFn func(error)(error , bool)
func (_e *MockErrorHandler_Expecter) Test(caseFn interface{}) *MockErrorHandler_Test_Call {
	return &MockErrorHandler_Test_Call{Call: _e.mock.On("Test", caseFn)}
}

func (_c *MockErrorHandler_Test_Call) Run(run func(caseFn func(error) (error, bool))) *MockErrorHandler_Test_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(func(error) (error, bool)))
	})
	return _c
}

func (_c *MockErrorHandler_Test_Call) Return(_a0 arpc.ErrorHandler) *MockErrorHandler_Test_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockErrorHandler_Test_Call) RunAndReturn(run func(func(error) (error, bool)) arpc.ErrorHandler) *MockErrorHandler_Test_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockErrorHandler creates a new instance of MockErrorHandler. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockErrorHandler(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockErrorHandler {
	mock := &MockErrorHandler{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
